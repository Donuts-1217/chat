<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ğŸ”¥ æ ¡åœ’èŠå¤©å®¤ï¼ˆDiscord é¢¨æ ¼ï¼‰</title>
<!-- Tailwind CSS for modern styling -->
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root{
    --bg:#0f1724; --panel:#111827; --muted:#9ca3af; --accent:#5865f2; --accent-2:#2ecc71; --danger:#ef4444;
    --card:#0b1020; --header-bg: #1e293b;
    --list-hover: rgba(255, 255, 255, 0.05);
    --selected-item: rgba(88, 101, 242, 0.15); /* Light accent background */
  }
  *{
    box-sizing:border-box;
    font-family:'Inter', 'Noto Sans TC', system-ui, -apple-system, sans-serif;
  }
  body{
    margin:0;
    background:linear-gradient(180deg,#071025 0%, #071223 100%);
    color:#e6eef8;
  }
  a{color:inherit}
  .center{
    display:flex;
    align-items:center;
    justify-content:center;
    height:100vh;
    width:100%;
  }

  /* Custom Scrollbar for Dark Theme */
  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: var(--panel); }
  ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.15); border-radius: 4px; }
  ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.25); }

  /* APP layout */
  #app{
    max-width:1400px;
    margin:18px auto;
    height:calc(100vh - 36px);
    display:flex;
    flex-direction:column;
  }
  .header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 18px;
    background: var(--header-bg);
    border-radius: 12px 12px 0 0;
  }
  .logo{font-weight:800;color:var(--accent);font-size:20px}

  .container{
    display:flex;
    flex: 1;
    gap:12px;
    padding:0 18px 18px 18px;
    background: var(--bg);
    border-radius: 0 0 12px 12px;
  }
  
  /* Sidebar styles */
  .sidebar{
    width:280px;
    background:var(--panel);
    border-radius:12px;
    padding:12px;
    display:flex;
    flex-direction:column;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    flex-shrink: 0;
  }
  .sidebar .me{
    padding:10px;
    background:rgba(255,255,255,0.06);
    border-radius:8px;
    margin-bottom:8px;
    border-left: 3px solid var(--accent);
  }
  .section-title{font-size:13px;color:var(--muted);margin:12px 0 6px 0; font-weight: 600;}
  .list{flex: 1; overflow-y: auto; padding:6px; border-radius:8px; background:rgba(255,255,255,0.02)}
  .item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:8px;
    border-radius:8px;
    margin-bottom:4px;
    cursor:pointer;
    transition: background-color 0.2s;
  }
  .item:hover{background:var(--list-hover)}
  .item.active{background:var(--selected-item); border-left: 2px solid var(--accent);}
  
  /* Chat Window styles */
  .chat-container{
    flex:1;
    display:flex;
    flex-direction:column;
    gap:12px;
    overflow: hidden;
  }
  .chat-window-wrapper {
    display: flex;
    flex: 1;
    overflow-x: auto;
    gap: 12px;
    padding-bottom: 5px; /* for scrollbar */
  }
  .chat-window{
    min-width: 320px;
    width: 320px;
    max-width: 450px; /* Limit individual chat width */
    height: 100%;
    background:var(--card);
    border-radius:12px;
    box-shadow:0 8px 30px rgba(2,6,23,0.6);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    flex-shrink: 0;
  }
  .chat-head{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:12px 14px;
    background:linear-gradient(90deg,var(--accent),#6d78ff);
    color:white;
    font-weight:700;
    flex-shrink: 0;
  }
  .chat-head.group-chat{
    background:linear-gradient(90deg,#8e44ad,#a075b8); /* Purple for groups */
  }
  .chat-body{
    padding:12px;
    overflow-y:auto;
    flex:1;
    background:var(--bg);
    display: flex;
    flex-direction: column;
  }
  .msg-wrapper {
    display: flex;
    margin: 6px 0;
  }
  .msg{
    background:rgba(255,255,255,0.06);
    padding:8px 12px;
    border-radius:18px;
    max-width:85%;
    word-break:break-word;
    color:#e6eef8;
    position: relative;
    font-size: 14px;
    line-height: 1.4;
  }
  .msg .sender-name {
    font-size: 11px;
    font-weight: 600;
    color: #4a71d2;
    margin-bottom: 2px;
    display: block;
  }
  .msg.me{
    background:var(--accent-2); /* Green for me */
    margin-left:auto;
    color: var(--card);
    border-radius: 18px 18px 2px 18px;
  }
  .msg.me .sender-name{
     color: var(--card); /* Dark text for green background */
  }
  .msg.other {
    margin-right: auto;
    border-radius: 18px 18px 18px 2px;
    background: #27303d;
  }
  .msg .timestamp {
    display: block;
    font-size: 10px;
    color: var(--muted);
    text-align: right;
    margin-top: 4px;
  }
  .msg.me .timestamp {
    color: #0b1020;
  }
  .chat-foot{
    display:flex;
    gap:8px;
    padding:12px;
    background:rgba(255,255,255,0.02);
    align-items:flex-end;
    flex-shrink: 0;
  }
  textarea{
    flex:1;
    min-height:64px;
    max-height:180px;
    padding:10px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.04);
    background:var(--panel);
    color:inherit;
    resize:vertical;
    transition: border-color 0.2s;
  }
  textarea:focus {
    outline: none;
    border-color: var(--accent);
  }

  /* Utility classes */
  .btn{
    padding:8px 12px;
    border-radius:8px;
    border:none;
    background:var(--accent);
    color:white;
    cursor:pointer;
    font-weight: 600;
    transition: background-color 0.2s, box-shadow 0.2s;
  }
  .btn:hover{
    background: #6c78ff;
    box-shadow: 0 2px 5px rgba(88, 101, 242, 0.4);
  }
  .btn.alt{
    background:transparent;
    border:1px solid rgba(255,255,255,0.1);
    color:#e6eef8;
    padding: 6px 10px;
    font-size: 13px;
    display: inline-flex;
    align-items: center;
  }
  .btn.alt:hover{
    background: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.2);
    box-shadow: none;
  }
  .btn.danger{background:var(--danger); border: none;}
  .btn.danger:hover{background: #ff5757;}
  .small{font-size:13px;color:var(--muted)}

  /* Modal styles */
  .custom-modal{
    position:fixed;inset:0;
    display:none;align-items:center;justify-content:center;
    background:rgba(2,6,23,0.8);
    z-index:100;
    backdrop-filter: blur(5px);
  }
  .custom-modal .box{
    width:92%;max-width:400px;
    background:linear-gradient(180deg,#1e293b,#0f172a);
    border-radius:10px;
    padding:20px;
    box-shadow:0 12px 40px rgba(2,6,23,0.8);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  /* responsive */
  @media(max-width:1024px){
    .container{
      flex-direction:column;
      padding:0 10px 10px 10px;
      gap: 10px;
    }
    #app {
      margin: 10px auto;
      height: calc(100vh - 20px);
    }
    .header {
      border-radius: 8px 8px 0 0;
      padding: 10px;
    }
    .sidebar{width:100%; height: 320px; flex-shrink: 0;}
    .chat-container{ order: 1; flex: 1; }
    .chat-window-wrapper { flex-wrap: wrap; justify-content: flex-start; }
    .chat-window { min-width: 95%; max-width: 95%; height: auto; }
  }
</style>
</head>
<body>

<!-- APP -->
<div id="app" style="display:none">
  <div class="header">
    <div class="logo">ğŸ”¥ æ ¡åœ’èŠå¤©å®¤</div>
    <div class="top-controls flex items-center gap-3">
      <div class="small" id="meInfo"></div>
      <div id="roleBadge" class="px-3 py-1 text-xs font-semibold rounded-full hidden" style="background:var(--accent-2); color: var(--card);"></div>
      <button id="logoutBtn" class="btn alt">ç™»å‡º</button>
    </div>
  </div>

  <div class="container">
    <!-- Sidebar: User Lists and Controls -->
    <div class="sidebar">
      <div class="me">
        <p class="font-bold text-sm truncate" id="myEmail">Email:</p>
        <p class="text-xs text-gray-400">ID: <span id="myUserId"></span></p>
      </div>

      <!-- Controls -->
      <div class="flex gap-2 mb-3 flex-wrap">
        <button id="addFriendBtn" class="btn alt flex-1">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><line x1="19" y1="8" x2="19" y2="14"></line><line x1="16" y1="11" x2="22" y2="11"></line></svg>
          <span class="ml-1">åŠ å¥½å‹</span>
        </button>
        <button id="monitorBtn" class="btn alt flex-1 hidden">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z"></path><circle cx="12" cy="12" r="3"></circle></svg>
          <span class="ml-1">ç›£çœ‹</span>
        </button>
        <button id="createGroupBtn" class="btn alt flex-1 hidden" style="background: rgba(142, 68, 173, 0.2); border-color: rgba(142, 68, 173, 0.4);">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
          <span class="ml-1">å»ºç¾¤çµ„</span>
        </button>
      </div>
      
      <!-- Groups List (New Feature) -->
      <div class="section-title">ç¾¤çµ„é »é“</div>
      <div id="groupsList" class="list">
        <p class="small text-center py-4 text-gray-500">è¼‰å…¥ä¸­...</p>
      </div>

      <!-- Friends List -->
      <div class="section-title">ç§äººè¨Šæ¯ / å¥½å‹</div>
      <div id="friendsList" class="list">
        <p class="small text-center py-4 text-gray-500">è¼‰å…¥ä¸­...</p>
      </div>

      <!-- Users List -->
      <div class="section-title">æ‰€æœ‰ä½¿ç”¨è€…</div>
      <div id="usersList" class="list">
        <p class="small text-center py-4 text-gray-500">è¼‰å…¥ä¸­...</p>
      </div>
    </div>

    <!-- Chat Area: Active Chat Windows -->
    <div class="chat-container">
      <div class="chat-window-wrapper" id="chatWindows">
        <div class="center text-gray-500 text-lg font-semibold w-full h-full">
          é»æ“Šå·¦å´ä½¿ç”¨è€…æˆ–ç¾¤çµ„é–‹å§‹èŠå¤©
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Loading State -->
<div id="loading" class="center">
  <div class="flex flex-col items-center">
    <div class="w-10 h-10 border-4 border-l-transparent rounded-full animate-spin border-blue-500 mb-3"></div>
    <p class="text-gray-300">èº«ä»½é©—è­‰ä¸­...</p>
  </div>
</div>

<!-- Custom Modal for Alerts/Confirms/Prompts -->
<div id="customModal" class="custom-modal">
  <div class="box">
    <h3 id="modalTitle" class="text-xl font-bold mb-3">è¨Šæ¯</h3>
    <div id="modalBody" class="text-sm text-gray-300 mb-4"></div>
    <div id="modalFooter" class="flex justify-end gap-2">
      <!-- Buttons injected here -->
    </div>
  </div>
</div>

<script type="module">
  // Modern Firebase V11 Modular Imports
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
  import { getAuth, signInWithCustomToken, onAuthStateChanged, signOut, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, addDoc, onSnapshot, collection, query, where, serverTimestamp, orderBy, limit, deleteDoc, updateDoc, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
  import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
  
  // setLogLevel('debug'); // é–‹å•Ÿ debug log

  /* ================= Global Variables & Environment ================= */
  // å˜—è©¦å¾ç’°å¢ƒè®Šæ•¸ä¸­å–å¾—é…ç½®ï¼Œå¦‚æœå¤±æ•—å‰‡ä½¿ç”¨ç©ºç‰©ä»¶
  const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
  const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
  const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

  // æª¢æŸ¥é…ç½®æ˜¯å¦æœ‰æ•ˆ (ä¿®æ­£æ‚¨é‡åˆ°çš„éŒ¯èª¤)
  if (!firebaseConfig || !firebaseConfig.apiKey) {
    loadingEl.innerHTML = '<p class="text-red-500">éŒ¯èª¤ï¼šFirebase é…ç½®éºå¤±ã€‚è«‹ç¢ºèªç’°å¢ƒè®Šæ•¸ `__firebase_config` å·²è¨­ç½®ä¸”åŒ…å« `apiKey`ã€‚</p>';
    throw new Error("Firebase config missing. Please check if __firebase_config is correctly injected.");
  }
  
  let ME_EMAIL = '';
  let ME_UID = '';
  let ME_NAME = '';
  let ME_ROLE = 'user'; // default role
  let FRIENDS = {};
  let USERS = {};
  let GROUPS = {}; // {groupName: {data}}

  const openChats = {}; // {roomId: {unsub: function, element: HTMLElement}}
  const unsubs = []; // Array to store all Firestore unsub functions

  /* ================= Custom Modal (replaces alert/confirm) ================= */

  /**
   * é¡¯ç¤ºè‡ªå®šç¾©æ¨¡æ…‹è¦–çª—
   * @param {string} title æ¨™é¡Œ
   * @param {string} message è¨Šæ¯å…§å®¹ (å¯åŒ…å« HTML å’Œ input)
   * @param {string} type 'alert' or 'prompt' or 'confirm'
   * @param {string} placeholder prompt input placeholder
   * @returns {Promise<string|boolean>} æ ¹æ“š type è¿”å› prompt çš„è¼¸å…¥å€¼æˆ– true/false
   */
  function showCustomModal(title, message, type = 'alert', placeholder = '') {
    return new Promise(resolve => {
      modalTitle.textContent = title;
      // Clear previous content but keep the new message text
      modalBody.innerHTML = message; 
      modalFooter.innerHTML = '';

      let inputEl = null;
      if (type === 'prompt') {
        // Re-inject the input field since modalBody was just set
        modalBody.innerHTML = `<p class="mb-4">${message}</p>`;
        inputEl = document.createElement('input');
        inputEl.type = 'text';
        inputEl.placeholder = placeholder;
        inputEl.className = 'w-full p-2 rounded bg-gray-700 border border-gray-600 text-white focus:outline-none focus:border-blue-500';
        modalBody.appendChild(inputEl);
      }

      if (type === 'prompt' || type === 'confirm') {
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'btn alt';
        cancelBtn.textContent = 'å–æ¶ˆ';
        cancelBtn.onclick = () => { customModal.style.display = 'none'; resolve(type === 'prompt' ? null : false); };
        modalFooter.appendChild(cancelBtn);

        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'btn ml-2';
        confirmBtn.textContent = type === 'prompt' ? 'ç¢ºèª' : 'ç¢ºå®š';
        confirmBtn.onclick = () => {
          customModal.style.display = 'none';
          if (type === 'prompt') {
            resolve(inputEl.value.trim());
          } else {
            resolve(true);
          }
        };
        modalFooter.appendChild(confirmBtn);

      } else { // type === 'alert'
        const closeBtn = document.createElement('button');
        closeBtn.className = 'btn';
        closeBtn.textContent = 'é—œé–‰';
        closeBtn.onclick = () => { customModal.style.display = 'none'; resolve(true); };
        modalFooter.appendChild(closeBtn);
      }
      customModal.style.display = 'flex';
      if (inputEl) inputEl.focus();
    });
  }

  /* ================= Firebase Initialization & Auth ================= */

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // Helper to construct secure Firestore collection paths
  const getPrivateCollectionPath = (collectionName) => {
    return `artifacts/${appId}/users/${ME_UID}/${collectionName}`;
  };
  // Note: For public collections, the path structure is fixed
  const getPublicCollectionPath = (collectionName) => {
    return `artifacts/${appId}/public/data/${collectionName}`;
  };
  const getUsersCollectionPath = () => {
    return `artifacts/${appId}/users`;
  };

  /**
   * Generates a consistent private chat room ID between two users,
   * regardless of the order of their UIDs/Emails.
   * Private chat room IDs are always sorted and contain '@' (for email)
   * Group room IDs are just the group name and do NOT contain '@'
   * @param {string} email1
   * @param {string} email2
   * @returns {string} consistent private room ID (emailA_emailB)
   */
  const getPrivateRoomId = (email1, email2) => {
    return [email1, email2].sort().join('_');
  };

  /**
   * Handle user sign-in using custom token or anonymously if token is missing.
   * Updates global ME_UID, ME_EMAIL.
   */
  async function handleSignIn() {
    try {
      if (initialAuthToken) {
        await signInWithCustomToken(auth, initialAuthToken);
      } else {
        await signInAnonymously(auth);
      }
    } catch (error) {
      console.error("Auth Error:", error);
      await showCustomModal('èº«ä»½é©—è­‰å¤±æ•—', 'ç„¡æ³•å®Œæˆèº«ä»½é©—è­‰ï¼Œè«‹è¿”å›ç™»å…¥é é¢é‡è©¦ã€‚', 'alert');
      // window.location.href = 'index.html'; // Removed redirect for testing ease
    }
  }

  /* ================= Core App Setup ================= */
  onAuthStateChanged(auth, async (user) => {
    if (!user) {
      // If user logs out or session expires, redirect to login
      loadingEl.style.display = 'flex';
      appEl.style.display = 'none';
      return; 
    }
    
    ME_UID = user.uid;
    ME_EMAIL = user.email || `anonymous_${ME_UID}@anon.chat`; // Use consistent fake email for anonymous users
    ME_NAME = user.email ? user.email.split('@')[0] : `åŒ¿åä½¿ç”¨è€…`;

    // 1. è¨»å†Šä½¿ç”¨è€…è³‡è¨Šåˆ° Firestore (ä½¿ç”¨ email ä½œç‚º public doc ID)
    const userRef = doc(db, getPublicCollectionPath('users'), ME_EMAIL);
    const userDoc = await getDoc(userRef);
    
    if (!userDoc.exists()) {
      await setDoc(userRef, {
        uid: ME_UID, // Add UID to public user doc for lookup
        email: ME_EMAIL,
        name: ME_NAME,
        lastActive: serverTimestamp(),
        role: 'user', // default to user
      });
      ME_ROLE = 'user';
    } else {
      await updateDoc(userRef, { lastActive: serverTimestamp(), uid: ME_UID }); // Update UID in case of change
      ME_ROLE = userDoc.data().role || 'user';
    }

    // æ›´æ–° UI é¡¯ç¤º
    myEmailEl.textContent = ME_EMAIL;
    myUserIdEl.textContent = ME_UID.substring(0, 10) + '...'; 
    if (ME_ROLE === 'superadmin') {
      roleBadgeEl.classList.remove('hidden');
      roleBadgeEl.textContent = 'ç®¡ç†å“¡';
      monitorBtn.classList.remove('hidden');
      createGroupBtn.classList.remove('hidden'); // Show group creation button for admin
    } else if (ME_ROLE === 'admin') {
      roleBadgeEl.classList.remove('hidden');
      roleBadgeEl.textContent = 'å°ç·¨';
      createGroupBtn.classList.remove('hidden');
    }


    // 2. å•Ÿå‹•æ‰€æœ‰ Firestore ç›£è½
    startListeners();

    // 3. é¡¯ç¤ºæ‡‰ç”¨ç¨‹å¼
    loadingEl.style.display = 'none';
    appEl.style.display = 'flex';
  });

  /* ================= Firestore Listeners ================= */

  function startListeners() {
    // 1. ç›£è½æ‰€æœ‰å…¬å…±ä½¿ç”¨è€… (Public/data/users)
    const usersQ = query(collection(db, getPublicCollectionPath('users')));
    const unsubUsers = onSnapshot(usersQ, (snapshot) => {
      usersListEl.innerHTML = '';
      USERS = {};
      let userHtml = '';

      snapshot.forEach(doc => {
        const userData = doc.data();
        const email = userData.email;
        const name = userData.name;
        const uid = userData.uid; // Use the UID stored in the public doc
        USERS[email] = { name, email, uid };

        if (email !== ME_EMAIL) {
          // Check if already a friend
          const isFriend = FRIENDS[email] && FRIENDS[email].status === 'friend';
          const buttonText = isFriend ? 'è¨Šæ¯' : 'åŠ å¥½å‹';
          const buttonClass = isFriend ? 'bg-blue-600 hover:bg-blue-700' : 'bg-gray-600 hover:bg-gray-700';
          
          userHtml += `
            <div class="item flex items-center" data-email="${email}">
              <div class="flex-1 truncate" onclick="openPrivateChat('${email}')">
                <span class="font-bold">${name}</span> 
                <span class="small ml-1 text-gray-400">(${email.split('@')[0]})</span>
                <span class="text-xs text-blue-400 ml-1">UID: ${uid.substring(0, 4)}...</span>
              </div>
              <button class="btn alt text-xs ${buttonClass} py-1 px-2 ml-2" onclick="handleUserAction('${email}', '${isFriend ? 'chat' : 'request'}')">${buttonText}</button>
            </div>
          `;
        }
      });
      usersListEl.innerHTML = userHtml || '<p class="small text-center py-2 text-gray-500">ç›®å‰æ²’æœ‰å…¶ä»–ä½¿ç”¨è€…ã€‚</p>';
    }, console.error);
    unsubs.push(unsubUsers);
    
    // 2. ç›£è½å¥½å‹é—œä¿‚ (Friendships) - Private data
    const friendRef = collection(db, getPrivateCollectionPath('friends'));
    const unsubFriends = onSnapshot(friendRef, (snapshot) => {
      friendsListEl.innerHTML = '';
      FRIENDS = {};
      let friendHtml = '';

      snapshot.forEach(doc => {
        const data = doc.data();
        const otherEmail = doc.id; // doc ID is the other user's email
        const status = data.status;
        const name = data.name || otherEmail.split('@')[0];
        
        FRIENDS[otherEmail] = { ...data, email: otherEmail };

        let statusBadge = '';
        let buttonAction = '';
        let itemClass = '';

        if (status === 'pending') {
          // Incoming request
          if (data.to === ME_EMAIL) {
            statusBadge = `<span class="text-xs bg-yellow-600 text-white rounded-full px-2 py-0.5 ml-2">å¾…ç¢ºèª</span>`;
            buttonAction = `<button class="btn text-xs py-1 px-2 ml-2" onclick="acceptFriend('${otherEmail}')">æ¥å—</button>`;
          } else {
          // Outgoing request
            statusBadge = `<span class="text-xs bg-gray-600 text-white rounded-full px-2 py-0.5 ml-2">ç­‰å¾…ä¸­</span>`;
            buttonAction = '';
          }
        } else if (status === 'friend') {
          statusBadge = `<span class="text-xs bg-green-600 text-white rounded-full px-2 py-0.5 ml-2">å¥½å‹</span>`;
          buttonAction = `<button class="btn alt text-xs py-1 px-2 ml-2" onclick="openPrivateChat('${otherEmail}')">èŠå¤©</button>`;
          itemClass = 'font-semibold';
        }

        friendHtml += `
          <div class="item flex items-center ${itemClass}">
            <div class="flex-1 truncate">
              <span class="font-bold">${name}</span> 
              <span class="small ml-1 text-gray-400">(${otherEmail.split('@')[0]})</span>
              ${statusBadge}
            </div>
            ${buttonAction}
          </div>
        `;
      });
      friendsListEl.innerHTML = friendHtml || '<p class="small text-center py-4 text-gray-500">æ²’æœ‰å¥½å‹æˆ–è«‹æ±‚ã€‚</p>';
      
      // Re-render users list to update button states (re-trigger listeners)
      // Note: In a real environment, you might optimize this to avoid re-rendering the whole user list.
      const usersRef = collection(db, getPublicCollectionPath('users'));
      getDocs(usersRef).then(snapshot => {
         // This is a crude way to trigger the previous onSnapshot callback's rendering logic. 
         // For now, we rely on the fact that USERS is already populated by the first unsubUsers.
      }).catch(console.error);
    }, console.error);
    unsubs.push(unsubFriends);

    // 3. ç›£è½ç¾¤çµ„ (Groups) - Public data
    const groupRef = collection(db, getPublicCollectionPath('groups'));
    const unsubGroups = onSnapshot(groupRef, (snapshot) => {
        groupsListEl.innerHTML = '';
        GROUPS = {};
        let groupHtml = '';

        snapshot.forEach(doc => {
            const data = doc.data();
            const groupName = doc.id;
            
            // Only show groups that the user is a member of
            if (data.members.includes(ME_EMAIL)) {
                GROUPS[groupName] = data;
                const isAdmin = data.admins.includes(ME_EMAIL);
                
                groupHtml += `
                    <div class="item flex items-center" onclick="openGroupChat('${groupName}')">
                        <div class="flex-1 truncate">
                            <span class="font-bold text-blue-300"># ${data.displayName}</span>
                            <span class="small ml-1 text-gray-400">(${data.members.length} ä½æˆå“¡)</span>
                        </div>
                        ${isAdmin ? '<span class="text-xs bg-red-600 text-white rounded-full px-2 py-0.5 ml-2">ç®¡ç†</span>' : ''}
                    </div>
                `;
            }
        });
        groupsListEl.innerHTML = groupHtml || '<p class="small text-center py-4 text-gray-500">æ²’æœ‰åŠ å…¥çš„ç¾¤çµ„ã€‚</p>';
    }, console.error);
    unsubs.push(unsubGroups);
  }

  /* ================= Chat Window Management ================= */

  /**
   * Opens or focuses a chat window.
   * @param {string} roomId The unique identifier for the chat (e.g., emailA_emailB or GroupName).
   * @param {string} title The title to display (e.g., Name, Group Name).
   * @param {string} type 'private' or 'group' or 'monitor'
   */
  window.openChatWindow = (roomId, title, type) => {
    
    // 1. æª¢æŸ¥ä¸¦èšç„¦ç¾æœ‰çª—å£
    if (openChats[roomId]) {
      openChats[roomId].element.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
      return;
    }
    
    // 2. ç§»é™¤ "é»æ“Šé–‹å§‹èŠå¤©" æç¤º
    if (chatWindowsEl.querySelector('.center')) {
      chatWindowsEl.querySelector('.center').remove();
    }

    const isGroup = type === 'group';
    const isMonitor = type === 'monitor';
    const isPrivate = type === 'private';
    let roomPath;

    if (isGroup || isMonitor) {
        // Group or Monitor uses the group/room ID directly
        roomPath = roomId;
    } else {
        // Private chat uses the consistent sorted email ID
        const parts = roomId.split('_'); // roomId here is the sorted email string
        if (parts.length === 2) {
             roomPath = roomId;
        } else {
             console.error("Invalid private roomId format:", roomId);
             showCustomModal('éŒ¯èª¤', 'èŠå¤©å®¤ ID æ ¼å¼éŒ¯èª¤ã€‚', 'alert');
             return;
        }
    }

    // 3. å‰µå»ºæ–°çš„èŠå¤©çª—å£ DOM
    const chatWindow = document.createElement('div');
    chatWindow.id = `chat-${roomId}`;
    chatWindow.className = 'chat-window';
    chatWindow.innerHTML = `
      <div class="chat-head ${isGroup ? 'group-chat' : ''}">
        <div class="truncate">
            ${isGroup ? '<span style="font-size: 1.2em; margin-right: 5px;">#</span>' : ''}
            ${title} ${isMonitor ? '(ç›£çœ‹)' : ''}
        </div>
        <button class="text-white hover:text-gray-200 ml-2" onclick="closeChatWindow('${roomId}')">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
      </div>
      <div id="messages-${roomId}" class="chat-body">
        <p class="small text-center text-gray-500">è¼‰å…¥è¨Šæ¯ä¸­...</p>
      </div>
      <div class="chat-foot">
        <textarea id="input-${roomId}" placeholder="è¼¸å…¥è¨Šæ¯ (Enter ç™¼é€, Shift+Enter æ›è¡Œ)" rows="2"></textarea>
        <button id="send-${roomId}" class="btn">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        </button>
      </div>
    `;
    
    chatWindowsEl.appendChild(chatWindow);
    chatWindow.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });


    // 4. å•Ÿå‹•è¨Šæ¯ç›£è½
    const messagesEl = document.getElementById(`messages-${roomId}`);
    const messageQ = query(
      collection(db, getPublicCollectionPath('messages'), roomPath, 'chats'),
      orderBy('time', 'asc')
    );

    const unsubMessages = onSnapshot(messageQ, (snapshot) => {
      // 5. æ¸²æŸ“è¨Šæ¯
      renderMessages(messagesEl, snapshot);
    }, console.error);

    // 6. è¨»å†Šç™¼é€äº‹ä»¶
    const sendBtn = document.getElementById(`send-${roomId}`);
    const inputEl = document.getElementById(`input-${roomId}`);
    
    // Pass the actual roomPath (which is the Firestore document ID) and the type
    sendBtn.onclick = () => sendMessage(roomPath, inputEl, isPrivate ? roomId.split('_').find(e => e !== ME_EMAIL) : null, isPrivate);
    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { 
        e.preventDefault(); 
        sendBtn.click(); 
      }
    });

    // 7. å­˜å„²ç›£è½å™¨å’Œå…ƒç´ 
    openChats[roomId] = {
      unsub: unsubMessages,
      element: chatWindow,
      type: type
    };
  };

  /**
   * Renders messages into the chat window.
   */
  function renderMessages(messagesEl, snapshot) {
    const shouldScroll = messagesEl.scrollHeight - messagesEl.scrollTop <= messagesEl.clientHeight + 50;
    
    messagesEl.innerHTML = ''; // æ¸…ç©ºèˆŠè¨Šæ¯
    snapshot.forEach(doc => {
      const msg = doc.data();
      const isMe = msg.from === ME_EMAIL;
      const msgClass = isMe ? 'me' : 'other';
      
      const senderName = isMe 
        ? ME_NAME 
        : (USERS[msg.from]?.name || msg.from.split('@')[0] || 'æœªçŸ¥ç”¨æˆ¶');
      
      let timeStr = 'ç™¼é€ä¸­...';
      if (msg.time && msg.time.toDate) {
        const date = msg.time.toDate();
        timeStr = date.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit' });
      }

      const msgHtml = `
        <div class="msg-wrapper">
          <div class="msg ${msgClass}">
            <span class="sender-name">${senderName}</span>
            <span>${msg.text}</span>
            <span class="timestamp">${timeStr}</span>
          </div>
        </div>
      `;
      messagesEl.innerHTML += msgHtml;
    });

    // æ»¾å‹•åˆ°åº•éƒ¨
    if (shouldScroll || snapshot.docChanges().length > 0 && snapshot.docChanges()[0].type === 'added') {
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
  }

  /**
   * Sends a message to the specified room.
   * @param {string} roomPath The Firestore document ID for the chat room.
   * @param {HTMLElement} inputEl The textarea element.
   * @param {string} otherEmail The recipient's email (only for private chat block check).
   * @param {boolean} isPrivate Whether it's a private chat.
   */
  async function sendMessage(roomPath, inputEl, otherEmail, isPrivate) {
    const text = inputEl.value.trim();
    if (!text) return;

    try {
      // 1. æª¢æŸ¥æ˜¯å¦è¢«å°é– (åƒ…ç§äººèŠå¤©éœ€è¦æª¢æŸ¥)
      if (isPrivate) {
        const blockedRef = doc(db, getPrivateCollectionPath('blocked'), otherEmail);
        const blockedDoc = await getDoc(blockedRef);
        if (blockedDoc.exists()) {
          showCustomModal('ç„¡æ³•ç™¼é€', 'æ‚¨å·²è¢«å°æ–¹å°é–ï¼Œç„¡æ³•ç™¼é€è¨Šæ¯ã€‚', 'alert');
          inputEl.value = '';
          return;
        }
      }
      
      // 2. ç™¼é€è¨Šæ¯ (Public/data/messages/{roomPath}/chats)
      const chatRef = collection(db, getPublicCollectionPath('messages'), roomPath, 'chats');

      await addDoc(chatRef, {
        from: ME_EMAIL,
        text: text,
        time: serverTimestamp()
      });

      inputEl.value = '';
      inputEl.style.height = '64px'; // Reset height
    } catch (error) {
      console.error("Send message error:", error);
      showCustomModal('ç™¼é€å¤±æ•—', 'è¨Šæ¯ç™¼é€å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–æ¬Šé™ã€‚', 'alert');
    }
  }

  /**
   * Closes a chat window and unsubscribes from its listener.
   */
  window.closeChatWindow = (roomId) => {
    if (openChats[roomId]) {
      // Unsubscribe from Firestore listener
      openChats[roomId].unsub();
      // Remove the element from DOM
      openChats[roomId].element.remove();
      // Remove from the map
      delete openChats[roomId];
    }
    // If no windows left, show placeholder
    if (Object.keys(openChats).length === 0) {
      chatWindowsEl.innerHTML = `
        <div class="center text-gray-500 text-lg font-semibold w-full h-full">
          é»æ“Šå·¦å´ä½¿ç”¨è€…æˆ–ç¾¤çµ„é–‹å§‹èŠå¤©
        </div>
      `;
    }
  };


  /* ================= Actions & Handlers ================= */

  /** Opens a private chat window for friends or known users. */
  window.openPrivateChat = (email) => {
    const user = USERS[email];
    if (!user) {
      showCustomModal('ä½¿ç”¨è€…ä¸å­˜åœ¨', 'è©²ä½¿ç”¨è€…è³‡è¨Šå¯èƒ½å°šæœªåŒæ­¥æˆ–ä¸å­˜åœ¨ã€‚', 'alert');
      return;
    }
    const name = user.name || email.split('@')[0];
    const roomId = getPrivateRoomId(ME_EMAIL, email); // Consistent ID for private chat
    openChatWindow(roomId, name, 'private');
  };
  
  /** Opens a group chat window. */
  window.openGroupChat = (groupName) => {
    const group = GROUPS[groupName];
    if (!group) {
        showCustomModal('ç¾¤çµ„ä¸å­˜åœ¨', 'è©²ç¾¤çµ„è³‡è¨Šå¯èƒ½å°šæœªåŒæ­¥æˆ–æ‚¨ä¸æ˜¯æˆå“¡ã€‚', 'alert');
        return;
    }
    const title = group.displayName;
    openChatWindow(groupName, title, 'group'); // GroupName is the room ID
  };

  /** Handles the button click on the users list. */
  window.handleUserAction = (email, actionType) => {
    if (actionType === 'chat') {
      openPrivateChat(email);
    } else if (actionType === 'request') {
      sendFriendRequest(email);
    }
  };

  /** Send a friend request to another user. */
  async function sendFriendRequest(otherEmail) {
    if (FRIENDS[otherEmail] && FRIENDS[otherEmail].status !== 'blocked') {
      if (FRIENDS[otherEmail].status === 'friend') {
        showCustomModal('å·²æ˜¯å¥½å‹', `${otherEmail} å·²åœ¨æ‚¨çš„å¥½å‹åå–®ä¸­ã€‚`, 'alert');
        return;
      }
      if (FRIENDS[otherEmail].status === 'pending') {
        showCustomModal('ç­‰å¾…ä¸­', `æ‚¨å·²å‘ ${otherEmail} ç™¼é€éå¥½å‹è«‹æ±‚ï¼Œè«‹è€å¿ƒç­‰å¾…ã€‚`, 'alert');
        return;
      }
    }

    try {
      const otherUser = USERS[otherEmail];
      if (!otherUser) {
        showCustomModal('ç™¼é€å¤±æ•—', 'ç„¡æ³•æ‰¾åˆ°è©²ä½¿ç”¨è€…è³‡è¨Šä¾†ç™¼é€è«‹æ±‚ã€‚', 'alert');
        return;
      }

      const batch = writeBatch(db);

      // 1. åœ¨è‡ªå·±çš„ 'friends' subcollection è¨˜éŒ„ç‚º outgoing pending
      const myFriendRef = doc(db, getPrivateCollectionPath('friends'), otherEmail);
      batch.set(myFriendRef, {
        email: otherEmail,
        name: otherUser.name || otherEmail.split('@')[0],
        status: 'pending',
        to: otherEmail, 
        from: ME_EMAIL,
        time: serverTimestamp()
      }, { merge: true });

      // 2. åœ¨å°æ–¹çš„ 'friends' subcollection è¨˜éŒ„ç‚º incoming pending
      const otherFriendRef = doc(db, `artifacts/${appId}/users/${otherUser.uid}/friends`, ME_EMAIL);
      batch.set(otherFriendRef, {
        email: ME_EMAIL,
        name: ME_NAME,
        status: 'pending',
        to: otherEmail, 
        from: ME_EMAIL,
        time: serverTimestamp()
      }, { merge: true });

      await batch.commit();

      showCustomModal('è«‹æ±‚å·²ç™¼é€', `å·²å‘ ${otherEmail} ç™¼é€å¥½å‹è«‹æ±‚ã€‚`, 'alert');

    } catch (error) {
      console.error("Send friend request error:", error);
      showCustomModal('ç™¼é€å¤±æ•—', 'ç™¼é€å¥½å‹è«‹æ±‚å¤±æ•—ã€‚', 'alert');
    }
  }

  /** Accept an incoming friend request. */
  window.acceptFriend = async (otherEmail) => {
    try {
      const otherUser = USERS[otherEmail];
      if (!otherUser) {
         showCustomModal('æ“ä½œå¤±æ•—', 'ç„¡æ³•æ‰¾åˆ°å°æ–¹è³‡è¨Šã€‚', 'alert');
         return;
      }

      const batch = writeBatch(db);
      
      // 1. Update my friend status to 'friend'
      const myFriendRef = doc(db, getPrivateCollectionPath('friends'), otherEmail);
      batch.update(myFriendRef, { status: 'friend', acceptedAt: serverTimestamp() });
      
      // 2. Update their friend status to 'friend' (needs their UID)
      const otherFriendRef = doc(db, `artifacts/${appId}/users/${otherUser.uid}/friends`, ME_EMAIL);
      batch.update(otherFriendRef, { status: 'friend', acceptedAt: serverTimestamp() });
      
      await batch.commit();

      showCustomModal('å·²æ¥å—', `æ‚¨å·²æ¥å— ${otherEmail} çš„å¥½å‹è«‹æ±‚ï¼`, 'alert');
      openPrivateChat(otherEmail); // Automatically open chat window

    } catch (error) {
      console.error("Accept friend error:", error);
      showCustomModal('æ¥å—å¤±æ•—', 'æ¥å—å¥½å‹è«‹æ±‚å¤±æ•—ã€‚', 'alert');
    }
  };


  /* ================= Group Management (Admin Only) ================= */

  /** Shows a modal for group creation. */
  createGroupBtn.onclick = async () => {
    if (ME_ROLE !== 'superadmin' && ME_ROLE !== 'admin') {
      showCustomModal('æ¬Šé™ä¸è¶³', 'åƒ…ç®¡ç†å“¡å¯å»ºç«‹ç¾¤çµ„ã€‚', 'alert');
      return;
    }

    const groupName = await showCustomModal(
      'å»ºç«‹æ–°ç¾¤çµ„',
      `
      <p>è«‹è¼¸å…¥ç¾¤çµ„åç¨± (è‹±æ–‡/æ•¸å­—ï¼Œå°‡ä½œç‚ºç¾¤çµ„ ID):</p>
      <p class="text-yellow-400 text-xs mt-2">æ³¨æ„ï¼šID ä¸€æ—¦å»ºç«‹ä¸å¯æ›´æ”¹ã€‚</p>
      `,
      'prompt',
      'ä¾‹å¦‚: math_club'
    );
    
    // Validate groupName format: letters, numbers, and underscore only
    const groupNamePattern = /^[a-zA-Z0-9\_]+$/;
    if (!groupName || groupName.length < 3 || !groupNamePattern.test(groupName)) {
        if (groupName !== null) showCustomModal('è¼¸å…¥ç„¡æ•ˆ', 'ç¾¤çµ„ ID å¿…é ˆæ˜¯è‹±æ–‡ã€æ•¸å­—æˆ–åº•ç·šï¼Œä¸”é•·åº¦è‡³å°‘ç‚º 3 å€‹å­—å…ƒã€‚', 'alert');
        return;
    }
    
    const displayName = await showCustomModal(
      'ç¾¤çµ„é¡¯ç¤ºåç¨±',
      'è«‹è¼¸å…¥ç¾¤çµ„çš„é¡¯ç¤ºåç¨± (ä¸­æ–‡/è‹±æ–‡çš†å¯):',
      'prompt',
      'ä¾‹å¦‚: æ•¸å­¸ç ”è¨ç¤¾'
    );
    
    if (!displayName || displayName.length < 1) {
        if (displayName !== null) showCustomModal('è¼¸å…¥ç„¡æ•ˆ', 'è«‹è¼¸å…¥ç¾¤çµ„é¡¯ç¤ºåç¨±ã€‚', 'alert');
        return;
    }

    // Optional: Add members modal (for simplicity, we'll start with just the admin/creator)
    const initialMembers = [ME_EMAIL];
    const initialAdmins = [ME_EMAIL];

    // Final confirmation and creation
    const confirmed = await showCustomModal(
        'ç¢ºèªå»ºç«‹ç¾¤çµ„',
        `<p>ç¾¤çµ„ ID: <strong>${groupName}</strong></p><p>é¡¯ç¤ºåç¨±: <strong>${displayName}</strong></p><p>åˆå§‹ç®¡ç†å“¡/æˆå“¡: ${ME_EMAIL}</p>`,
        'confirm'
    );

    if (confirmed) {
        await createGroup(groupName, displayName, initialMembers, initialAdmins);
    }
  };

  /** Creates the group document in Firestore. */
  async function createGroup(groupName, displayName, members, admins) {
    try {
      const groupRef = doc(db, getPublicCollectionPath('groups'), groupName);
      const groupDoc = await getDoc(groupRef);

      if (groupDoc.exists()) {
        showCustomModal('å»ºç«‹å¤±æ•—', `ç¾¤çµ„ ID <strong>${groupName}</strong> å·²å­˜åœ¨ã€‚`, 'alert');
        return;
      }
      
      await setDoc(groupRef, {
        displayName: displayName,
        members: members,
        admins: admins,
        createdAt: serverTimestamp(),
        createdBy: ME_EMAIL
      });

      showCustomModal('å»ºç«‹æˆåŠŸ', `ç¾¤çµ„ <strong>${displayName}</strong> å·²æˆåŠŸå»ºç«‹ï¼`, 'alert');
      openGroupChat(groupName);

    } catch (error) {
      console.error("Create group error:", error);
      showCustomModal('å»ºç«‹å¤±æ•—', 'å»ºç«‹ç¾¤çµ„æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥éŒ¯èª¤è¨Šæ¯ã€‚', 'alert');
    }
  }


  /* ================= UI Event Bindings ================= */
  
  // Add Friend via Prompt Modal
  addFriendBtn.onclick = async () => {
    const targetEmail = await showCustomModal(
      'æ–°å¢å¥½å‹',
      'è«‹è¼¸å…¥æ‚¨æƒ³æ–°å¢å¥½å‹çš„å®Œæ•´ Email åœ°å€:',
      'prompt',
      'example@school.edu'
    );
    
    if (targetEmail && targetEmail.includes('@')) {
      const normalizedEmail = targetEmail.toLowerCase(); // Ensure case consistency
      if (normalizedEmail === ME_EMAIL) {
        showCustomModal('ç„¡æ•ˆæ“ä½œ', 'æ‚¨ä¸èƒ½æ–°å¢è‡ªå·±ç‚ºå¥½å‹ã€‚', 'alert');
      } else if (USERS[normalizedEmail]) {
        sendFriendRequest(normalizedEmail);
      } else {
        showCustomModal('ä½¿ç”¨è€…ä¸å­˜åœ¨', 'è©² Email ä¸åœ¨ä½¿ç”¨è€…åˆ—è¡¨ä¸­ï¼Œè«‹ç¢ºèªè¼¸å…¥æ­£ç¢ºã€‚', 'alert');
      }
    } else if (targetEmail !== null) {
      showCustomModal('è¼¸å…¥ç„¡æ•ˆ', 'è«‹è¼¸å…¥ä¸€å€‹æœ‰æ•ˆçš„ Email åœ°å€ã€‚', 'alert');
    }
  };

  // Monitor Private Chat (Admin only)
  monitorBtn.onclick = async () => {
    if (ME_ROLE !== 'superadmin' && ME_ROLE !== 'admin') {
      showCustomModal('æ¬Šé™ä¸è¶³', 'åƒ…ç®¡ç†å“¡å¯ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚', 'alert');
      return;
    }

    const input = await showCustomModal(
      'ç›£çœ‹ç§äººèŠå¤©',
      'è«‹è¼¸å…¥å…©ä½ç”¨æˆ¶çš„ Email (ä»¥åº•ç·šåˆ†éš”, e.g., userA@a_userB@b):',
      'prompt',
      'emailA@a.com_emailB@b.com'
    );
    
    if (input) {
      const parts = input.split('_');
      if (parts.length === 2 && parts[0].includes('@') && parts[1].includes('@')) {
        const emailA = parts[0].trim().toLowerCase();
        const emailB = parts[1].trim().toLowerCase();
        
        // Use the consistent private room ID logic (sorted)
        const roomId = getPrivateRoomId(emailA, emailB); 
        openChatWindow(roomId, `ç›£çœ‹: ${emailA.split('@')[0]} & ${emailB.split('@')[0]}`, 'monitor');
      } else {
        showCustomModal('æ ¼å¼éŒ¯èª¤', 'è«‹ç¢ºä¿æ ¼å¼ç‚º emailA@domain.com_emailB@domain.comã€‚', 'alert');
      }
    }
  };

  // Logout Handler
  logoutBtn.onclick = async () => {
    const confirmed = await showCustomModal('ç¢ºèªç™»å‡º', 'æ‚¨ç¢ºå®šè¦ç™»å‡ºèŠå¤©å®¤å—ï¼Ÿ', 'confirm');
    if (confirmed) {
      // Clean up listeners before signing out
      Object.values(openChats).forEach(o => o.unsub && o.unsub());
      unsubs.forEach(u => u && u());
      await signOut(auth);
      // onAuthStateChanged will handle the clean up and UI state
    }
  };

  // Clean up listeners when leaving the page (redundant due to signout cleanup, but good practice)
  window.addEventListener('beforeunload', () => {
    Object.values(openChats).forEach(o => o.unsub && o.unsub());
    unsubs.forEach(u => u && u());
  });

  // Initial Sign-In Attempt
  if (!auth.currentUser) {
    handleSignIn();
  }
</script>
</body>
</html>